
<html>
<head>
<title>Networking Basics Tutorial</title>
</head>
<body bgcolor="#99CCCC">
<div align="center"><h1><b>Sniff v2.2</b></h1></div>
<div align="center"><h2><b>Networking Basics Tutorial</b></h2></div>
<font size="+1">
<div align="right"><b>January 17, 2005</b></div>
<hr>
<h2><b>1. Introduction</b></h2>
<p>Sniff v2.2 is a network monitoring tool developed for platforms running POSIX Operating Systems. It's intended to be used for the monitoring, analysis and summarising of all the packet activity in the network. In order to make the best use of the tool, the users need to have sufficient understanding of the basic concepts of computer networking. This tutorial tries to cover certain aspects of basic computer networking that the users of Sniff must know before using the tool. The treatment presented in this tutorial is limited to few basic concepts and is exhaustive neither in depth nor in breadth. For further details about the tool refer to the <a href="sniff2.2-manual.html">User Documentation</a>, <a href="sniff2.2-sdd.html">Design Document</a> and <a href="sniff2.2-srs.html">System Requirements</a>.</p>

<h2><b>2. History</b></h2>
<p>The field of computer networking and today's Internet trace their beginnings back to the early 1960s, a time at which the telephone network was the world's dominant communication network. The prevalent technology in those days was based on circuit-switching techniques where two nodes were connected by a dedicated analog circuit during the entire duration of network use. Given the increasing importance (and great expense) of computers during this period and the advent of timeshared computers, it was perhaps natural (at least with perfect hindsight!) to consider the question of how to hook computers together so that they could be shared among geographically distributed users.  The traffic generated by such users was likely to be "bursty" with respect to the intervals of activity; like for instance, the sending of a command to a remote computer, followed by periods of inactivity, while waiting for a reply or while contemplating the received response. The circuit-switching techniques were clearly not reliable and efficient enough to sustain such traffics.</p>

<p>Three research groups around the world, all unaware of the others' work, began inventing the notion of <i>packet-switching</i> as an efficient and robust alternative to circuit-switching.  The first published work on packet-switching techniques was the work by Leonard Kleinrock, at that time a graduate student at MITs. Using queuing theory, Kleinrock's work elegantly demonstrated the effectiveness of the packet-switching approach for bursty traffic sources. At the same time, Paul Baran at the Rand Institute had begun investigating the  use of packet-switching for secure voice over military networks, while at the National Physical Laboratory in England, Donald Davies and Roger Scantlebury were also developing their ideas on packet switching. The work at MIT, Rand, and NPL laid the foundations for contemporary computer networking.</p>

<h2><b>3. Packet-Switching Technology</b></h2>
<h3><b>3.1 Packets</b></h3>
<p>Packet-switching technology was developed as an efficient and robust alternative to circuit-switching technology and was tailor-made for computer networks. In packet switching, all the data coming out of a machine is broken up into chunks, each chunk has the address of where it came from and where it is going. This enables chunks of data from many different sources to co-mingle on the same lines, and be sorted and directed to different routes by special machines along the way. In this way, many people can use the same lines at the same time. Also, there is no need for maintaining a dedicated circuit between the machines for the entire duration of communication between the nodes. These chunks of data, which function as vehicles of inter-node communication, are called <i>packets</i>. Each packet must contain the information it needs to get to its destination as the network treats the packets as independent entities and routes them across many machines from the source to the destination. Packets are typically few kilo-bytes in size. The network tries to send the packets through the best route available, while avoiding troublesome parts.</p>

<h3><b>3.2 Protocol</b></h3>
<p>For meaningful communication between two machines in a computer network, the destination machine must be able to organise the data received from the source machine in the same order it was sent. Also, the destination must detect and/or correct any error in the data received. All these factors necessitate a formal description of message formats and the rules that the two computers must follow to exchange those messages. These pre-determined standard rules are called <i>protocols</i>. Protocols are designed keeping in mind the nature of data to be transmitted and the nature of the medium used for transmission.</p>

<h2><b>4. Anatomy of Packets</b></h2>
<p>Packets are organised into distinct parts to make both transmission and reception convenient. Most packets are split into three parts:
<ul>
<li><b>Header:</b> The header contains instructions about the data carried by the packet. These instructions may include:
<ul> 
<li>Length of packet (some networks have fixed-length packets, while others rely on the header to contain this information)</li>
<li>Synchronization (a few bits that help the packet match up to the network)</li>
<li>Packet number (which packet this is in a sequence of packets)</li>
<li>Protocol (on networks that carry multiple types of information, the protocol defines what type of packet is being transmitted: e-mail, Web page, streaming video)</li>
<li>Destination address (where the packet is going)</li>
<li>Originating address (where the packet came from)</li>
</ul></li>

<div align="center">
<img src="https://github.com/kameshr/sniff/blob/master/docs/packet.jpg"></img><br>
<i>Anatomy of a Packet</i></div><br>

<li><b>Payload:</b> This is the actual data that the packet is delivering to the destination. If a packet is fixed-length, then the payload may be padded with blank information to make it of the right size.</li>
<li><b>Trailer:</b> The trailer, sometimes called the footer, typically contains a couple of bits that tell the receiving device that it has reached the end of the packet. It may also have some type of error checking. The most common error checking technique used in packets is <i>Cyclic Redundancy Check</i> (CRC). CRC is pretty neat. For instance in some computer networks, it takes the sum of all the 1s in the payload and adds them together. The result is stored as a hexadecimal value in the trailer. The receiving device adds up the 1s in the payload and compares the result to the value stored in the trailer. If the values match, the packet is good. But if the values do not match, the receiving device sends a request to the originating device to resend the packet.</li>
</ul></p>

<h2><b>5. Protocol Layers</b></h2>
<p>Transmission of packets across large computer networks can turn out to be a complex task. The packets are sent through many machines in their route to their final destination. Therefore at any instant of time, the packets need to know their immediate (next) stop as well as their ultimate destination. Also, there is another constraint that the destination machine should be able to organise the packets in the same order they were sent. Added to all these, we also need to detect and correct errors in transmission. Finally, we may need to maintain the state of (the actual) communication between the source and destination machines. It is hard to design a single protocol that satisfies all these needs. So, computer network designers deploy a system of inter-linked protocols to accomplish all the goals mentioned.</p>
<p>As described above the chief kinds of protocols are as follows:
<ul>
<li><b>Machine Protocols:</b> These protocols carry the packets from a machine to the next stop (the next machine in the route, not necessarily the destination machine). They carry the hardware identification of the machines so that the network hardware of the appropriate machine captures the packet. Also, suitable error detection and correction mechanisms are built into the protocol to minimise transmission errors.</li>
<li><b>Network Protocols:</b> These protocols convey the network about the final destination machine the packet is headed towards. Routing decisions made during the course of transmitting the packet across the network are based on this information. Information regarding the source machine is also conveyed.</li>
<li><b>Transport Protocols:</b> These protocols ensure that the packets that reach the destination machine are organised in the right order. They abstract the entire network as a pipe through which the packets travel in the right order across the network from the source machine to the destination machine. They handle errors in transmission and packet losses by scheduling appropriate re-transmissions.</li>
<li><b>Application Protocols:</b> These protocols carry out the actual communication between the machines across the virtual pipe established by the transport protocols. They maintain the state of communication and handle encryption and errors in data transmitted.</li>
</ul>

<div align="center">
<img src="https://github.com/kameshr/sniff/blob/master/docs/protocol.JPG"></img><br>
<i>Computer Network Protocol Stack</i></div><br>
</p>

<p>It is easy to see how the protocol system assumes a layered architecture. Higher layer protocols have greater scope; from merely finding the next machine to stop, to maintaining the state of the message being conveyed between the source and destination machines. This layered architecture of protocols is called <i>protocol stack</i>.</p>

<h2><b>6. What does Sniff do?</b></h2>
<p>Sniff does complete analysis of the machine, network and transport layer protocols of all the packets being transmitted in the network. The information extracted is logged and a succinct online summary giving both machine-wise and protocol-wise analysis is displayed. Such a summary may be used to get a bird's eye view of the packet activity in the network and diagnose aberrations that might be present in the network.</p>
<hr>
<i>Project developed by Kamesh Raghavendra (<a href="mailto: kameshr@gmail.com">kameshr@gmail.com</a>) under the guidance of Prof. R Kalyana Krishnan, Dept. of CSE, IIT Madras</i>
</font>
</body>
</html>
